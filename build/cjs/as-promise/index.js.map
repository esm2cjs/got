{
  "version": 3,
  "sources": ["../../esm/as-promise/index.js"],
  "sourcesContent": ["import { EventEmitter } from 'node:events';\nimport is from '@esm2cjs/is';\nimport PCancelable from '@esm2cjs/p-cancelable';\nimport { HTTPError, RetryError, } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress',\n];\nexport default function asPromise(firstRequest) {\n    let globalRequest;\n    let globalResponse;\n    let normalizedOptions;\n    const emitter = new EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        onCancel(() => {\n            globalRequest.destroy();\n        });\n        onCancel.shouldReject = false;\n        onCancel(() => {\n            reject(new CancelError(globalRequest));\n        });\n        const makeRequest = (retryCount) => {\n            // Errors when a new request is made after the promise settles.\n            // Used to detect a race condition.\n            // See https://github.com/sindresorhus/got/issues/1489\n            onCancel(() => { });\n            const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            globalRequest = request;\n            request.once('response', async (response) => {\n                // Parse body\n                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = response.rawBody;\n                }\n                else {\n                    try {\n                        response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fall back to `utf8`\n                        response.body = response.rawBody.toString();\n                        if (isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    const hooks = options.hooks.afterResponse;\n                    for (const [index, hook] of hooks.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            options.merge(updatedOptions);\n                            options.prefixUrl = '';\n                            if (updatedOptions.url) {\n                                options.url = updatedOptions.url;\n                            }\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            throw new RetryError(request);\n                        });\n                        if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n                            throw new TypeError('The `afterResponse` hook returned an invalid value');\n                        }\n                    }\n                }\n                catch (error) {\n                    request._beforeError(error);\n                    return;\n                }\n                globalResponse = response;\n                if (!isResponseOk(response)) {\n                    request._beforeError(new HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    request.destroy();\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options?.body;\n            request.once('retry', (newRetryCount, error) => {\n                firstRequest = undefined;\n                const newBody = request.options.body;\n                if (previousBody === newBody && is.nodeStream(newBody)) {\n                    error.message = 'Cannot retry with consumed body stream';\n                    onError(error);\n                    return;\n                }\n                // This is needed! We need to reuse `request.options` because they can get modified!\n                // For example, by calling `promise.json()`.\n                normalizedOptions = request.options;\n                makeRequest(newRetryCount);\n            });\n            proxyEvents(request, emitter, proxiedRequestEvents);\n            if (is.undefined(firstRequest)) {\n                void request.flush();\n            }\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    promise.off = (event, fn) => {\n        emitter.off(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (globalRequest.options) {\n            const { headers } = globalRequest.options;\n            if (!globalRequest.writableFinished && !('accept' in headers)) {\n                headers.accept = 'application/json';\n            }\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\n"],
  "mappings": "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",
  "names": ["PCancelable", "Request", "_a", "is", "proxyEvents"]
}
