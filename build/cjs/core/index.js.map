{
  "version": 3,
  "sources": ["../../esm/core/index.js"],
  "sourcesContent": ["import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport { URL, URLSearchParams } from 'node:url';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@esm2cjs/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError, } from '@esm2cjs/cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@esm2cjs/is';\nimport { buffer as getBuffer } from 'get-stream';\nimport { FormDataEncoder, isFormData as isFormDataLike } from '@esm2cjs/form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError, } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n];\nconst noop = () => { };\nexport default class Request extends Duplex {\n    constructor(url, options, defaults) {\n        super({\n            // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0,\n        });\n        // @ts-expect-error - Ignoring for now.\n        Object.defineProperty(this, 'constructor', {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_noPipe\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"requestUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"redirectUrls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopRetry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_downloadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_uploadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopReading\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pipedServerResponses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_responseSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bodySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_unproxyEvents\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isFromCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cannotHaveBody\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_triggerRead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cancelTimeouts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nativeResponse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_flushed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aborted\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // We need this because `this._request` if `undefined` when using cache\n        Object.defineProperty(this, \"_requestInitialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._downloadedSize = 0;\n        this._uploadedSize = 0;\n        this._stopReading = false;\n        this._pipedServerResponses = new Set();\n        this._cannotHaveBody = false;\n        this._unproxyEvents = noop;\n        this._triggerRead = false;\n        this._cancelTimeouts = noop;\n        this._jobs = [];\n        this._flushed = false;\n        this._requestInitialized = false;\n        this._aborted = false;\n        this.redirectUrls = [];\n        this.retryCount = 0;\n        this._stopRetry = noop;\n        this.on('pipe', source => {\n            if (source.headers) {\n                Object.assign(this.options.headers, source.headers);\n            }\n        });\n        this.on('newListener', event => {\n            if (event === 'retry' && this.listenerCount('retry') > 0) {\n                throw new Error('A retry listener has been attached already.');\n            }\n        });\n        try {\n            this.options = new Options(url, options, defaults);\n            if (!this.options.url) {\n                if (this.options.prefixUrl === '') {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.options.url = '';\n            }\n            this.requestUrl = this.options.url;\n        }\n        catch (error) {\n            const { options } = error;\n            if (options) {\n                this.options = options;\n            }\n            this.flush = async () => {\n                this.flush = async () => { };\n                this.destroy(error);\n            };\n            return;\n        }\n        if (this.options.signal?.aborted) {\n            this.destroy(new AbortError(this));\n        }\n        this.options.signal?.addEventListener('abort', () => {\n            this.destroy(new AbortError(this));\n        });\n        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n        // The below is run only once.\n        const { body } = this.options;\n        if (is.nodeStream(body)) {\n            body.once('error', error => {\n                if (this._flushed) {\n                    this._beforeError(new UploadError(error, this));\n                }\n                else {\n                    this.flush = async () => {\n                        this.flush = async () => { };\n                        this._beforeError(new UploadError(error, this));\n                    };\n                }\n            });\n        }\n    }\n    async flush() {\n        if (this._flushed) {\n            return;\n        }\n        this._flushed = true;\n        try {\n            await this._finalizeBody();\n            if (this.destroyed) {\n                return;\n            }\n            await this._makeRequest();\n            if (this.destroyed) {\n                this._request?.destroy();\n                return;\n            }\n            // Queued writes etc.\n            for (const job of this._jobs) {\n                job();\n            }\n            // Prevent memory leak\n            this._jobs.length = 0;\n            this._requestInitialized = true;\n        }\n        catch (error) {\n            this._beforeError(error);\n        }\n    }\n    _beforeError(error) {\n        if (this._stopReading) {\n            return;\n        }\n        const { response, options } = this;\n        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n        this._stopReading = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        void (async () => {\n            // Node.js parser is really weird.\n            // It emits post-request Parse Errors on the same instance as previous request. WTF.\n            // Therefore we need to check if it has been destroyed as well.\n            //\n            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n            // but makes the response unreadable. So we additionally need to check `response.readable`.\n            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n                response.setEncoding(this.readableEncoding);\n                const success = await this._setRawBody(response);\n                if (success) {\n                    response.body = response.rawBody.toString();\n                }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    const retryOptions = options.retry;\n                    backoff = await retryOptions.calculateDelay({\n                        attemptCount,\n                        retryOptions,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculateRetryDelay({\n                            attemptCount,\n                            retryOptions,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,\n                        }),\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    await new Promise(resolve => {\n                        const timeout = setTimeout(resolve, backoff);\n                        this._stopRetry = () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        };\n                    });\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    try {\n                        for (const hook of this.options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedError, this.retryCount + 1);\n                        }\n                    }\n                    catch (error_) {\n                        void this._error(new RequestError(error_.message, error, this));\n                        return;\n                    }\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    this.destroy();\n                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {\n                        const request = new Request(options.url, updatedOptions, options);\n                        request.retryCount = this.retryCount + 1;\n                        process.nextTick(() => {\n                            void request.flush();\n                        });\n                        return request;\n                    });\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this._triggerRead = true;\n        const { response } = this;\n        if (response && !this._stopReading) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this._triggerRead = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this._requestInitialized) {\n            write();\n        }\n        else {\n            this._jobs.push(write);\n        }\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // We need to check if `this._request` is present,\n            // because it isn't when we use cache.\n            if (!this._request || this._request.destroyed) {\n                callback();\n                return;\n            }\n            this._request.end((error) => {\n                // The request has been destroyed before `_final` finished.\n                // See https://github.com/nodejs/node/issues/39356\n                if (this._request._writableState?.errored) {\n                    return;\n                }\n                if (!error) {\n                    this._bodySize = this._uploadedSize;\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this._request.emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this._requestInitialized) {\n            endRequest();\n        }\n        else {\n            this._jobs.push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        this._stopReading = true;\n        this.flush = async () => { };\n        // Prevent further retries\n        this._stopRetry();\n        this._cancelTimeouts();\n        if (this.options) {\n            const { body } = this.options;\n            if (is.nodeStream(body)) {\n                body.destroy();\n            }\n        }\n        if (this._request) {\n            this._request.destroy();\n        }\n        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    pipe(destination, options) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is.undefined(options.form);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const isJSON = !is.undefined(options.json);\n        const isBody = !is.undefined(options.body);\n        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (isForm || isJSON || isBody) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            // Serialize body\n            const noContentType = !is.string(headers['content-type']);\n            if (isBody) {\n                // Body is spec-compliant FormData\n                if (isFormDataLike(options.body)) {\n                    const encoder = new FormDataEncoder(options.body);\n                    if (noContentType) {\n                        headers['content-type'] = encoder.headers['Content-Type'];\n                    }\n                    if ('Content-Length' in encoder.headers) {\n                        headers['content-length'] = encoder.headers['Content-Length'];\n                    }\n                    options.body = encoder.encode();\n                }\n                // Special case for https://github.com/form-data/form-data\n                if (isFormData(options.body) && noContentType) {\n                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                }\n            }\n            else if (isForm) {\n                if (noContentType) {\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                const { form } = options;\n                options.form = undefined;\n                options.body = (new URLSearchParams(form)).toString();\n            }\n            else {\n                if (noContentType) {\n                    headers['content-type'] = 'application/json';\n                }\n                const { json } = options;\n                options.json = undefined;\n                options.body = options.stringifyJson(json);\n            }\n            const uploadBodySize = await getBodySize(options.body, options.headers);\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.  For example, a Content-Length header\n            // field is normally sent in a POST request even when the value is 0\n            // (indicating an empty payload body).  A user agent SHOULD NOT send a\n            // Content-Length header field when the request message does not contain\n            // a payload body and the method semantics do not anticipate such a\n            // body.\n            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n                headers['content-length'] = String(uploadBodySize);\n            }\n        }\n        if (options.responseType === 'json' && !('accept' in options.headers)) {\n            options.headers.accept = 'application/json';\n        }\n        this._bodySize = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        // This will be called e.g. when using cache so we need to check if this request has been aborted.\n        if (this.isAborted) {\n            return;\n        }\n        const { options } = this;\n        const { url } = options;\n        this._nativeResponse = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirectUrls;\n        typedResponse.request = this;\n        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        typedResponse.ok = isResponseOk(typedResponse);\n        this._isFromCache = typedResponse.isFromCache;\n        this._responseSize = Number(response.headers['content-length']) || undefined;\n        this.response = typedResponse;\n        response.once('end', () => {\n            this._responseSize = this._downloadedSize;\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._aborted = true;\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET',\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (promise) => {\n                    try {\n                        await promise;\n                    }\n                    catch { }\n                });\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n        if (this.isAborted) {\n            return;\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            this._cancelTimeouts();\n            this._unproxyEvents();\n            if (this.redirectUrls.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            this._request = undefined;\n            const updatedOptions = new Options(undefined, undefined, this.options);\n            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n            const canRewrite = statusCode !== 307 && statusCode !== 308;\n            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n            if (serverRequestedGet || userRequestedGet) {\n                updatedOptions.method = 'GET';\n                updatedOptions.body = undefined;\n                updatedOptions.json = undefined;\n                updatedOptions.form = undefined;\n                delete updatedOptions.headers['content-length'];\n            }\n            try {\n                // We need this in order to support UTF-8\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                const redirectUrl = new URL(redirectBuffer, url);\n                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                    return;\n                }\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in updatedOptions.headers) {\n                        delete updatedOptions.headers.host;\n                    }\n                    if ('cookie' in updatedOptions.headers) {\n                        delete updatedOptions.headers.cookie;\n                    }\n                    if ('authorization' in updatedOptions.headers) {\n                        delete updatedOptions.headers.authorization;\n                    }\n                    if (updatedOptions.username || updatedOptions.password) {\n                        updatedOptions.username = '';\n                        updatedOptions.password = '';\n                    }\n                }\n                else {\n                    redirectUrl.username = updatedOptions.username;\n                    redirectUrl.password = updatedOptions.password;\n                }\n                this.redirectUrls.push(redirectUrl);\n                updatedOptions.prefixUrl = '';\n                updatedOptions.url = redirectUrl;\n                for (const hook of updatedOptions.hooks.beforeRedirect) {\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(updatedOptions, typedResponse);\n                }\n                this.emit('redirect', updatedOptions, typedResponse);\n                this.options = updatedOptions;\n                await this._makeRequest();\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        // `HTTPError`s always have `error.response.body` defined.\n        // Therefore we cannot retry if `options.throwHttpErrors` is false.\n        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n        // but that wouldn't be possible since the body would be already read in `error.response.body`.\n        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this._triggerRead) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        if (this._noPipe) {\n            const success = await this._setRawBody();\n            if (success) {\n                this.emit('response', response);\n            }\n            return;\n        }\n        this.emit('response', response);\n        for (const destination of this._pipedServerResponses) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _setRawBody(from = this) {\n        if (from.readableEnded) {\n            return false;\n        }\n        try {\n            // Errors are emitted via the `error` event\n            const rawBody = await getBuffer(from);\n            // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n            // So in order to check if this was really successfull, we need to check if it has been properly ended.\n            if (!this.isAborted) {\n                this.response.rawBody = rawBody;\n                return true;\n            }\n        }\n        catch { }\n        return false;\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        timer(request);\n        if (this.options.http2) {\n            // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n            request.setTimeout(0);\n        }\n        this._cancelTimeouts = timedOut(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n        this._request = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        this._sendBody();\n        this.emit('request', request);\n    }\n    async _asyncWrite(chunk) {\n        return new Promise((resolve, reject) => {\n            super.write(chunk, error => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    _sendBody() {\n        // Send body\n        const { body } = this.options;\n        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n        if (is.nodeStream(body)) {\n            body.pipe(currentRequest);\n        }\n        else if (is.generator(body) || is.asyncGenerator(body)) {\n            (async () => {\n                try {\n                    for await (const chunk of body) {\n                        await this._asyncWrite(chunk);\n                    }\n                    super.end();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                }\n            })();\n        }\n        else if (!is.undefined(body)) {\n            this._writeRequest(body, undefined, () => { });\n            currentRequest.end();\n        }\n        else if (this._cannotHaveBody || this._noPipe) {\n            currentRequest.end();\n        }\n    }\n    _prepareCache(cache) {\n        if (!cacheableStore.has(cache)) {\n            const cacheableRequest = new CacheableRequest(((requestOptions, handler) => {\n                const result = requestOptions._request(requestOptions, handler);\n                // TODO: remove this when `cacheable-request` supports async request functions.\n                if (is.promise(result)) {\n                    // We only need to implement the error handler in order to support HTTP2 caching.\n                    // The result will be a promise anyway.\n                    // @ts-expect-error ignore\n                    // eslint-disable-next-line @typescript-eslint/promise-function-async\n                    result.once = (event, handler) => {\n                        if (event === 'error') {\n                            (async () => {\n                                try {\n                                    await result;\n                                }\n                                catch (error) {\n                                    handler(error);\n                                }\n                            })();\n                        }\n                        else if (event === 'abort') {\n                            // The empty catch is needed here in case when\n                            // it rejects before it's `await`ed in `_makeRequest`.\n                            (async () => {\n                                try {\n                                    const request = (await result);\n                                    request.once('abort', handler);\n                                }\n                                catch { }\n                            })();\n                        }\n                        else {\n                            /* istanbul ignore next: safety check */\n                            throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                        }\n                        return result;\n                    };\n                }\n                return result;\n            }), cache);\n            cacheableStore.set(cache, cacheableRequest.request());\n        }\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, urlToOptions(url));\n            let request;\n            // TODO: Fix `cacheable-response`. This is ugly.\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    const fix = () => {\n                        if (response.req) {\n                            response.complete = response.req.res.complete;\n                        }\n                    };\n                    response.prependOnceListener('end', fix);\n                    fix();\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        const { options } = this;\n        const { headers, username, password } = options;\n        const cookieJar = options.cookieJar;\n        for (const key in headers) {\n            if (is.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        if (username || password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            headers.authorization = `Basic ${credentials}`;\n        }\n        // Set cookies\n        if (cookieJar) {\n            const cookieString = await cookieJar.getCookieString(options.url.toString());\n            if (is.nonEmptyString(cookieString)) {\n                headers.cookie = cookieString;\n            }\n        }\n        // Reset `prefixUrl`\n        options.prefixUrl = '';\n        let request;\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                request = () => result;\n                break;\n            }\n        }\n        if (!request) {\n            request = options.getRequestFunction();\n        }\n        const url = options.url;\n        this._requestOptions = options.createNativeRequestOptions();\n        if (options.cache) {\n            this._requestOptions._request = request;\n            this._requestOptions.cache = options.cache;\n            this._requestOptions.body = options.body;\n            this._prepareCache(options.cache);\n        }\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : request;\n        try {\n            // We can't do `await fn(...)`,\n            // because stream `error` event can be emitted before `Promise.resolve()`.\n            let requestOrResponse = fn(url, this._requestOptions);\n            if (is.promise(requestOrResponse)) {\n                requestOrResponse = await requestOrResponse;\n            }\n            // Fallback\n            if (is.undefined(requestOrResponse)) {\n                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n                if (is.promise(requestOrResponse)) {\n                    requestOrResponse = await requestOrResponse;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._sendBody();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableCacheError) {\n                throw new CacheError(error, this);\n            }\n            throw error;\n        }\n    }\n    async _error(error) {\n        try {\n            if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n                // This branch can be reached only when using the Promise API\n                // Skip calling the hooks on purpose.\n                // See https://github.com/sindresorhus/got/issues/2103\n            }\n            else {\n                for (const hook of this.options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (!this._request || this._request.destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._request.write(chunk, encoding, (error) => {\n            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n            if (!error && !this._request.destroyed) {\n                this._uploadedSize += Buffer.byteLength(chunk, encoding);\n                const progress = this.uploadProgress;\n                if (progress.percent < 1) {\n                    this.emit('uploadProgress', progress);\n                }\n            }\n            callback(error);\n        });\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        return this.socket?.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get isAborted() {\n        return this._aborted;\n    }\n    get socket() {\n        return this._request?.socket ?? undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this._responseSize) {\n            percent = this._downloadedSize / this._responseSize;\n        }\n        else if (this._responseSize === this._downloadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._downloadedSize,\n            total: this._responseSize,\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this._bodySize) {\n            percent = this._uploadedSize / this._bodySize;\n        }\n        else if (this._bodySize === this._uploadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._uploadedSize,\n            total: this._bodySize,\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        return this._request?.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this._isFromCache;\n    }\n    get reusedSocket() {\n        return this._request?.reusedSocket;\n    }\n}\n"],
  "mappings": "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",
  "names": ["is", "process", "WeakableMap", "Options", "options", "calculateRetryDelay", "isFormDataLike", "isFormData", "getBodySize", "decompressResponse", "http", "isUnixSocketURL", "getBuffer", "timer", "timedOut", "TimedOutTimeoutError", "proxyEvents", "CacheableRequest", "handler", "urlToOptions", "isClientRequest", "CacheableCacheError"]
}
